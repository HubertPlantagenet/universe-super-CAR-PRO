L298N 驱动
    红外循迹
ULN 2003 双极性线性集成电路 多用于放大电流 承受很大的电流  可以直接驱动 继电器 蜂鸣器 马达 详见手册
首先  要求如果是  运行后通过cin输入 输入三个数 可以是整数 浮点数 和字符 然后将其排序输出
第一：按道理都可以用函数重载  三个函数重载 只需要改一下形参和中间变量的数据类型就可以了。
（感觉就是你同学那个样子，直接使用函数重载）
第二：使用函数模板，函数模板是可以用于目前你学的任意类型的 不论字符 整形（整数） 浮点型（小数）
但他的缺点很明显 ，在使用的时候必须手动在<>里面给出行参的数据类型，比如 在程序运行你输入数据前，
程序是不知道你输入的数据是什么类型的，调用不了函数模板。
 解决方法就是，利用sizeof（）函数 用以判断你输入的数据的数据类型 然后通过得到的数据类型 利用判断(switch)
来决定是执行 Mysort<char>(a,b,c) 还是 Mysort<float>(a,b,c) 还是 Mysort<int>(a,b,c)
 H函数的方法是这样  你需要知道 sizeof()这个函数  sizeof（a） 则返回变量a在编译器里面所占字节的大小 
如果sizeof(a) 等于1 则 a 是一个字符形变量， 返回4 则 a 是整形变量  flaot 同理 
然后当 sizeof(a)  == 1 时  调用 Mysort<char>(a,b,c)  
当sizeof(a) == 4   调用Mysort<int>(a,b,c) 


@全体成员  抢走我们嘉峰的那个学妹请注意，希望你能现在自觉补偿我们还在基地的学长奶茶，一共四杯（算上你的嘉峰学长），不然我们会让你的嘉峰学长体验一下什么是左右为男



吴老师   我们校基地软件部承办了今年的全国大学生计算机应用大赛，这个比赛难度并不大，其中办公软件office以及 C语言程序设计比赛 ，我们院的同学都可以去参加争取一下，我们大二同学已经学习了计算机文化基础，以及C语言和数据结构，有一定能力参加一下这个全国性的比赛 。
 很多同学到大二这个时候一场比赛都没参加过，我觉得这个比赛非常合适， 希望许老师能在我们八院推广一下让更多同学知道和了解这个比赛，积累同学们的赛事经验，为以后更多比赛做准备。 /拜托

吴老师你好，我是校基地软件部的胡竞予，同时也是现在八院大二学生，我们校基地软件部承办了今年的全国大学生计算机应用大赛，这个比赛难度不大，而且是首届，有一定office经验的，或者在入学前有学习编程、office 的同学，都可以去尝试参加，为之后的学习积累比赛经验。




#include<reg52.h>
#define uchar unsigned char
uchar receiveData;
sbit led = P0^0;
sbit led2 = P0^1;
void UsartConfiguration();
void main()
{
        UsartConfiguration();
        led = 0;
        led2 = 0;                         //检测是否接收到字符，即是否进入串行口中断
        TI = 0;
        while(1)
        {
                if(receiveData == 'A')
               led = 1;                //点亮
                if(receiveData == 'B')
                   led = 0;                //熄灭
        }
}
void UsartConfiguration()
{
        SCON=0X50;                        //设置为工作方式1
        TMOD=0X20;                        //设置计数器工作方式2
        PCON=0X80;                        //波特率加倍
        TH1=0XF3;                         //计数器初始值设置，注意波特率是4800的(晶振为12.0MHz)
        TL1=0XF3;
        ES=1;                             //打开接收中断
        EA=1;                             //打开总中断
        TR1=1;                            //打开计数器1
}

void Usart() interrupt 4                        //串行口中断，为什么是4可以参考上一篇中断的文章
{
    receiveData=SBUF;                      //出去接收到的数据
        RI = 0;                                //清除接收中断标志位
        SBUF=receiveData;                      //将接收到的数据放入到发送寄存器
        while(!TI);                            //等待发送数据完成
        TI=0;                                  //清除发送完成标志位
}
--------------------- 
作者：W_K_L 
来源：CSDN 
原文：https://blog.csdn.net/W_K_L/article/details/72597853 
版权声明：本文为博主原创文章，转载请附上博文链接！